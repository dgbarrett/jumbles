# My imports
from code.pycode.load import getPixels, getImage, getRawPixels
from code.pycode.lines import CompoundLine
from code.pycode.line_processing import (findSignificantHorizontalLines,
							 getNumberOfWordsInAnswer,
							 getAnswerHeight,
							 getClueEndPoint,
							 getAnswerStartPoint,
							 getFirstClueHeight,
							 buildCompoundLines,
							 getWordRegions)
from code.pycode.image_processing import extractImageArea, cropImage
from code.pycode.JumbleAnswerTemplate import JumbleAnswerTemplate
from code.pycode.jumble_solving import (solveClues, getAnswerFormat, Dictionary)

# Python imports
import os.path
import sys
from itertools import permutations
import random
import time

# Package imports
from pytesseract import image_to_string

MAX_Q_SIZE = 10000000


'''
Take in an image path, crop the bullshit out of the image, and save the cropped image.
'''
def step1(filename):
	filenameNoExt = filename.split(".")[-2]
	path = "images/{}".format(filename)
	savepath = "images/{}_cropped.png".format(filenameNoExt)

	# Get image pixels and size.
	pixels = getPixels(path)
	height = len(pixels)
	width = len(pixels[0])

	print("Starting STEP 1 (Cropping) for \"{}\".".format(filename))
	print("\tCleaning up image for particle analysis and text extraction...")

	lines = findSignificantHorizontalLines(pixels)

	# The number of words in the answer
	wordsInAnswer = getNumberOfWordsInAnswer(lines)
	# answerTop is the y position of the top of the answer area
	# answerTop is the y position of the bottom of the answer area
	answerTop, answerBottom = getAnswerHeight(lines, wordsInAnswer)
	# Get the x position where the clues end.
	clueEndPoint = getClueEndPoint(lines, answerTop)
	# Get leftmost x position of the answer entry.
	answerStartPoint = getAnswerStartPoint(lines, wordsInAnswer)

	# Top edge of the image in line with where the clues end.
	croppoint1 = (clueEndPoint + 1, 0)
	# Point right above the answer, all the way to the right side of the image.
	croppoint2 = (width, answerTop - 1)

	# Crop the comic and associated text out.
	print("\t\tCropping comic area out of the image.")
	cropImage(path, croppoint1, croppoint2, savepath)

	# Left edge of image right below answer.
	croppoint3 = (0, answerBottom + 1)
	# Bottom right corner of image.
	croppoint4 = (width, height)

	# Crop nonsense below the answer entry.
	print("\t\tCropping area below answer entry.")
	cropImage(savepath, croppoint3, croppoint4)

	# Now that image is cleaned up, we re-find the sig horizontal lines incase there was error before.
	pixels = getPixels(savepath)
	lines = findSignificantHorizontalLines(pixels)
	# Y position of the top of the first clue.
	firstWordHeight = getFirstClueHeight(lines)

	croppoint7 = (0,0)
	croppoint8 = (clueEndPoint, firstWordHeight - 1)
	
	# Crop out area above first clue.
	print("\t\tCropping area above first clue.")
	cropImage(savepath, croppoint7, croppoint8)

	compoundLines = buildCompoundLines(lines)
	delta = (0.6 * (compoundLines[1].minY - compoundLines[0].maxY))/2

	print("\tDone. Cropped image saved at \"{}\"".format(savepath))
	print("\t\t delta = {}px".format(delta))

'''
	Function: step2A
		Take in a path to an image.  Based on the name it locates the particle 
		data extracted from jx_cropped.png by the ImageJ macro and parses it to
		create an answer template for the word jumble.
'''
def step2A(filename):
	filenameNoExt = filename.split(".")[-2]
	datafilePath = "data/particle_data/{}_cropped.xls".format(filenameNoExt)

	print("Starting STEP 2A (template generation) for \"{}\".".format(filename))

	if not os.path.isfile(datafilePath):
		print("\tNo particle data file found for \"{}\"".format(filename))
		print("\t\t Expected a file to exist at \"{}\"".format(datafilePath))
		print("\nData files are generated by running \"count.ijm\"\n")
		exit(0)

	print("\tGenerating answer template.")
	template = JumbleAnswerTemplate(datafilePath)
	print("\tDone.")
	return template

'''
	Function: step2B
		Take in a path to a cropped image, and return a list of character
		sequences that make up the clues.
'''
def step2B(filename):
	filenameNoExt = filename.split(".")[-2]
	path = "images/{}_cropped.png".format(filenameNoExt) 

	print("Starting STEP 2B (Segmentation and OCR) for \"{}\".".format(filename))

	pixels = getPixels(path)

	lines = findSignificantHorizontalLines(pixels);
	compoundLines = buildCompoundLines(lines)

	delta = (0.6 * (compoundLines[1].minY - compoundLines[0].maxY))/2

	textCropPoints = getWordRegions(compoundLines)

	wordImages = []
	name = path.split(".")[0]
	for i, cropPointPair in enumerate(textCropPoints):
		savepath = "{}_word{}.png".format(name, i)
		wordImages.append(savepath)
		extractImageArea(path, cropPointPair[0], cropPointPair[1], savepath)

	imgStrings = []
	for file in wordImages:
		string = image_to_string(getImage(file))
		imgStrings.append(string.replace(" ", "").lower())

	print("\tOCR detected {}".format(imgStrings))
	print("\tDone.")

	return imgStrings, lines

'''
	Function: step3
		Solve the word jumble.
'''
def step3(filename):	
	answerTemplate = step2A(filename)
	clueStrings, lines = step2B(filename)

	print("Starting STEP 3 (solving) for \"{}\"".format(filename))
	print("\tExtracted {} clue strings from {}.".format(len(clueStrings), filename))

	for i, string in enumerate(clueStrings):
		print("\t\t{}. {}".format(i+1,string))

	print("\tSolving individual clue strings.")
	print("\tListing possible clue solutions.")
	possabilityDict = solveClues(clueStrings);
	for clueString, possibilites in possabilityDict.items():
		print("\t\t{}".format(clueString))
		for poss in possibilites:
			print("\t\t\t- {}".format(poss))

	for i, possWords in enumerate(list(possabilityDict.values())):
		answerTemplate.addAnswer(i, possWords[0])

	print("\tExtracting answer information.")

	# Total length of the answer (in letters)
	answerLength = answerTemplate.getTotalAnswerLength()
	print("\t\tAnswer must be {} total letters.".format(answerLength))
	
	# List containing the length of the words in the answer (in pixels)
	answerFormat = getAnswerFormat(lines)
	wordsInAnswer = len(answerFormat)
	print("\t\tAnswer must be {} words.".format(wordsInAnswer))

	# List containing the length of each word in the answer (in letters)
	answerWordLengths = [round(answerLength * (answerWordLen/sum(answerFormat))) for answerWordLen in answerFormat]

	for i,wlen in enumerate(answerWordLengths):
		print("\t\t\t word {} : {} letters.".format(i+1,wlen))

	jumbledCompleteAnswer = answerTemplate.getAnswerLetters()
	print("\t\tAnswer must consist of \"{}\"".format(jumbledCompleteAnswer))

	print("\t\tLoading dictionary.")
	dictionary = Dictionary()

	print("\t\tGenerating answer permutations.\n\t\tPartitioning permutations to match answer format.\n\t\tChecking permutations against dictionary.");
	
	#v1
	solutions = 0
	duplicateMap = {}

	for i,p in enumerate(permutations(jumbledCompleteAnswer)):
		phrase = []
		totallen = 0
		string = ''.join(p)

		if string not in duplicateMap:
			if len(duplicateMap) > MAX_Q_SIZE:
				duplicateMap.pop( random.choice( list(duplicateMap.keys() ) ) )  

			duplicateMap[string] = 0

			for wordlen in answerWordLengths:
				phrase.append(string[totallen:totallen+wordlen])
				totallen += wordlen

			for word in phrase:
				wordlen = len(word)

				try:
					x = dictionary[word[0]][wordlen][word];
				except Exception:
					break;
			else:
				solutions += 1
				solstr = ""
				for word in phrase:
					solstr += word + " "
				print("\t\t\tPOSSIBLE SOLUTION: {}".format(solstr))

	#v2
	# unique_perms = set(permutations(jumbledCompleteAnswer))
	# solutions = 0
	# for p in unique_perms:
	# 	phrase = []
	# 	totallen = 0
	# 	string = ''.join(p)

	# 	for wordlen in answerWordLengths:
	# 		phrase.append(string[totallen:totallen+wordlen])
	# 		totallen += wordlen

	# 	for word in phrase:
	# 		wordlen = len(word)

	# 		try:
	# 			x = dictionary[wordlen][word];
	# 		except Exception:
	# 			break;
	# 	else:
	# 		solutions += 1
	# 		solstr = ""
	# 		for word in phrase:
	# 			solstr += word + " "
	# 		print("\t\t\tPOSSIBLE SOLUTION: {}".format(solstr))
				

	print("Found {} total possible solutions.".format(solutions))

def main(argv):
	if argv[1] == "-crop":
		step1(argv[2])
	elif argv[1] == "-ocr":
		step2B(argv[2])
	elif argv[1] == "-solve":
		start_time = time.time()
		step3(argv[2])
		print("\nTime taken: {}s".format((time.time() - start_time)))
	elif argv[1] == "-template":
		template = step2A(argv[2])
		print("\n\nPrinting key letter locations (1) in clue entries.")
		for word in template.clueAnswerTemplates[:-1]:
			print(word)

if __name__ == "__main__":
	main(sys.argv)


